{"version":3,"sources":["Quadtree.js"],"names":["Rectangle","require","Quadtree","boundingBox","maxPointsPerNode","points","childNodes","point","containsPoint","length","push","x","y","w","h","max","ne","nw","se","sw","forEach","p","insertPoint","splice","el","range","pointsFound","overlapsRectangle","validPoints","filter","node","queryPoints","Set","module","exports"],"mappings":"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","file":"Quadtree.js","sourcesContent":["const Rectangle = require('./Rectangle');\n/**\n * Class describing the data-structure\n * for a Quadtree\n */\nclass Quadtree {\n  /**\n   * @constructor\n   * @param {Rectangle} boundingBox\n   * @param {int} maxPointsPerNode\n   */\n  constructor(boundingBox, maxPointsPerNode) {\n    this.boundingBox = boundingBox;\n    this.maxPointsPerNode = maxPointsPerNode;\n    this.points = [];\n    this.childNodes = [];\n  }\n  /**\n   * Inserts a point into the quadtree\n   * @param {Point} point\n   * @return {boolean}\n   */\n  insertPoint(point) {\n    // early return if the point isn't within the bounding box\n    if (!this.boundingBox.containsPoint(point)) {\n      return false;\n    }\n    // if is a Leaf node - i.e. no children and not full\n    if (this.points.length < this.maxPointsPerNode\n        && this.childNodes.length === 0) {\n      // insert Point\n      this.points.push(point);\n      return;\n    }\n    /**\n     * If is a leaf node but full, subdivide.\n     * split the bounding box into 4\n     * crate 4 new quadtrees with the 4 new boxes\n     * and set them as child nodes\n     */\n    if (this.childNodes.length === 0) {\n      const x = this.boundingBox.x;\n      const y = this.boundingBox.y;\n      const w = this.boundingBox.w / 2;\n      const h = this.boundingBox.h / 2;\n      const max = this.maxPointsPerNode;\n      const ne = new Quadtree(new Rectangle(x+w, y+h, w, h), max);\n      const nw = new Quadtree(new Rectangle(x, y+h, w, h), max);\n      const se = new Quadtree(new Rectangle(x+w, y, w, h), max);\n      const sw = new Quadtree(new Rectangle(x, y, w, h), max);\n      // add the quadtrees as child nodes\n      this.childNodes.push(ne, nw, se, sw);\n      // next, add the point that could\n      // not fit into the parent node\n      this.points.push(point);\n      // loop through all of the points and add them again\n      this.points.forEach((p) => {\n        this.insertPoint(p);\n      });\n      // empty the points array after they've been redistributed\n      this.points.splice(0, this.maxPointsPerNode+1);\n      return;\n    }\n    // if is not a leaf node, call insert on children\n    this.childNodes.forEach((el)=> {\n      el.insertPoint(point);\n    });\n  }\n  /**\n   * Find all points within a range\n   * @param {Rectangle} range\n   * @param {Array} pointsFound\n   * @return {Set}\n   */\n  queryPoints(range, pointsFound = []) {\n    if (typeof range === 'undefined') {\n      range = this.boundingBox;\n    }\n    // early return if range is outside of bounding box\n    if (!range.overlapsRectangle(this.boundingBox)) {\n      return;\n    }\n    // if is a Leaf node - i.e. no children\n    if (this.points.length > 0 && this.childNodes.length === 0) {\n      // add points\n      // range may overlap a box but the point could still be outside of\n      // the range\n      const validPoints = this.points.filter(\n          (point) => range.containsPoint(point));\n      pointsFound.push(...validPoints);\n      return;\n    }\n    // if has children\n    this.childNodes.forEach((node) => {\n      node.queryPoints(range, pointsFound); // recursive bit!\n    });\n    return new Set(pointsFound);\n  }\n}\nmodule.exports = Quadtree;\n"]}