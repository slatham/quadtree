{"version":3,"sources":["Quadtree.js"],"names":["Rectangle","require","Quadtree","boundingBox","maxPointsPerNode","points","childNodes","point","containsPoint","length","exists","some","p","isEqualTo","push","x","y","w","h","max","ne","nw","se","sw","forEach","insertPoint","splice","el","range","pointsFound","overlapsRectangle","validPoints","filter","node","queryPoints","Set","structure","getStructure","module","exports"],"mappings":"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","file":"Quadtree.js","sourcesContent":["const Rectangle = require('./Rectangle');\n/**\n * Class describing the data-structure\n * for a Quadtree\n */\nclass Quadtree {\n  /**\n   * @constructor\n   * @param {Rectangle} boundingBox\n   * @param {int} maxPointsPerNode\n   */\n  constructor(boundingBox, maxPointsPerNode) {\n    this.boundingBox = boundingBox;\n    this.maxPointsPerNode = maxPointsPerNode;\n    this.points = [];\n    this.childNodes = [];\n  }\n  /**\n   * Inserts a point into the quadtree\n   * @param {Point} point\n   * @return {boolean}\n   */\n  insertPoint(point) {\n    // early return if the point isn't within the bounding box\n    if (!this.boundingBox.containsPoint(point)) {\n      return false;\n    }\n    // if is a Leaf node - i.e. no children and not full\n    if (this.points.length < this.maxPointsPerNode\n        && this.childNodes.length === 0) {\n      // check if point already exists\n      // with the same values for x & y\n      const exists = this.points.some((p) => {\n        return p.isEqualTo(point);\n      });\n      // if the point is unique, insert it\n      if (!exists) {\n        this.points.push(point);\n      }\n      return;\n    }\n    /**\n     * If is a leaf node but full, subdivide.\n     * split the bounding box into 4\n     * crate 4 new quadtrees with the 4 new boxes\n     * and set them as child nodes\n     */\n    if (this.childNodes.length === 0) {\n      const x = this.boundingBox.x;\n      const y = this.boundingBox.y;\n      const w = this.boundingBox.w / 2;\n      const h = this.boundingBox.h / 2;\n      const max = this.maxPointsPerNode;\n      const ne = new Quadtree(new Rectangle(x+w, y+h, w, h), max);\n      const nw = new Quadtree(new Rectangle(x, y+h, w, h), max);\n      const se = new Quadtree(new Rectangle(x+w, y, w, h), max);\n      const sw = new Quadtree(new Rectangle(x, y, w, h), max);\n      // add the quadtrees as child nodes\n      this.childNodes.push(ne, nw, se, sw);\n      // next, add the point that could\n      // not fit into the parent node\n      // first, check the point has unique\n      // values for x & y\n      const exists = this.points.some((p) => {\n        return p.isEqualTo(point);\n      });\n      // if the point is unique, insert it\n      if (!exists) {\n        this.points.push(point);\n      }\n      // loop through all of the points and add them again\n      this.points.forEach((p) => {\n        this.insertPoint(p);\n      });\n      // empty the points array after they've been redistributed\n      this.points.splice(0, this.maxPointsPerNode+1);\n      return;\n    }\n    // if is not a leaf node, call insert on children\n    this.childNodes.forEach((el)=> {\n      el.insertPoint(point);\n    });\n  }\n  /**\n   * Find all points within a range\n   * @param {Rectangle} range\n   * @param {Array} pointsFound\n   * @return {Set}\n   */\n  queryPoints(range, pointsFound = []) {\n    if (typeof range === 'undefined') {\n      range = this.boundingBox;\n    }\n    // early return if range is outside of bounding box\n    if (!range.overlapsRectangle(this.boundingBox)) {\n      return;\n    }\n    // if is a Leaf node - i.e. no children\n    if (this.points.length > 0 && this.childNodes.length === 0) {\n      // add points\n      // range may overlap a box but the point could still be outside of\n      // the range\n      const validPoints = this.points.filter(\n          (point) => range.containsPoint(point));\n      pointsFound.push(...validPoints);\n    }\n    // if has children\n    this.childNodes.forEach((node) => {\n      node.queryPoints(range, pointsFound); // recursive bit!\n    });\n    return new Set(pointsFound);\n  }\n  /**\n   * Get the structure of the tree\n   * @param {Array} structure\n   * @return {Array}\n   */\n  getStructure(structure = []) {\n    // if is a leaf node, i.e. no children\n    // add to the structure.\n    if (this.childNodes.length === 0) {\n      structure.push(this.boundingBox);\n      return;\n    }\n    // if has children\n    this.childNodes.forEach((node) =>{\n      node.getStructure(structure);\n    });\n    return structure;\n  }\n}\nmodule.exports = Quadtree;\n"]}