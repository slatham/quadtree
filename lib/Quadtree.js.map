{"version":3,"sources":["../src/Quadtree.js"],"names":["Rectangle","require","Quadtree","boundingBox","maxPointsPerNode","points","childNodes","point","containsPoint","length","push","x","y","w","h","ne","nw","se","sw","forEach","insertPoint","p","splice","el","range","pointsFound","overlapsRectangle","validPoints","filter","reduce","acc","val","concat","node","queryPoints","Set","module","exports"],"mappings":"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","file":"Quadtree.js","sourcesContent":["const Rectangle = require('./Rectangle');\n\nclass Quadtree {\n\n    constructor(boundingBox,maxPointsPerNode) {\n    this.boundingBox = boundingBox;\n    this.maxPointsPerNode = maxPointsPerNode;\n    this.points = [];    \n    this.childNodes = [];  \n    //rect(this.boundingBox.x,this.boundingBox.y,this.boundingBox.w,this.boundingBox.h)\n    }\n    insertPoint (point) {\n        // early return if the point isn't within the bounding box\n        if (!this.boundingBox.containsPoint(point)) {\n            return false\n        } \n        // if is a Leaf node - i.e. no children and not full\n        if (this.points.length < this.maxPointsPerNode && this.childNodes.length === 0){\n            // insert Point\n            this.points.push(point);\n            return;\n        }\n        /** \n         * If is a leaf node but full, subdivide.\n         * split the bounding box into 4\n         * crate 4 new quadtrees with the 4 new boxes\n         * and set them as child nodes\n         */\n        if(this.childNodes.length === 0){\n            const x = this.boundingBox.x;\n            const y = this.boundingBox.y;\n            const w = this.boundingBox.w / 2;\n            const h = this.boundingBox.h / 2;\n            const ne = new Quadtree(new Rectangle(x+w,y+h,w,h),this.maxPointsPerNode);\n            const nw = new Quadtree(new Rectangle(x,y+h,w,h),this.maxPointsPerNode);\n            const se = new Quadtree(new Rectangle(x+w,y,w,h),this.maxPointsPerNode);\n            const sw = new Quadtree(new Rectangle(x,y,w,h),this.maxPointsPerNode);\n            // add the quadtrees as child nodes\n            this.childNodes.push(ne,nw,se,sw);\n            // next, add the point that could\n            // not fit into the parent node\n            this.points.push(point);\n            // loop through all of the points and add them again\n            this.points.forEach(p => {               \n                this.insertPoint(p)\n            });\n            \n            // empty the points array after they've been \n            // redistributed\n            this.points.splice(0,this.maxPointsPerNode+1);\n            return;\n        }\n        // if is not a leaf node, call insert on children\n        this.childNodes.forEach(el=> {\n            el.insertPoint(point)\n        });\n        \n    }\n\n    \n\n    queryPoints(range, pointsFound = []) {\n        \n        // early return if range is outside of bounding box\n        if(!range.overlapsRectangle(this.boundingBox)){\n            //return pointsFound.reduce((acc, val) => acc.concat(val), []);\n            return\n        }\n\n        // if is a Leaf node - i.e. no children\n        if (this.points.length > 0 && this.childNodes.length === 0){\n            // add points\n            let validPoints = this.points.filter(point => range.containsPoint(point))\n            \n            validPoints.reduce((acc, val) => acc.concat(val), []);\n            pointsFound.push(validPoints);\n            return\n            //return pointsFound.reduce((acc, val) => acc.concat(val), []);\n        }\n\n        // if has children\n     //   if(this.childNodes.length > 0) {\n            \n            this.childNodes.forEach(node => {\n                node.queryPoints(range, pointsFound);\n            })\n\n            //return pointsFound.reduce((acc, val) => acc.concat(val), []);\n    //    } \n\n        //return pointsFound\n        return new Set(pointsFound.reduce((acc, val) => acc.concat(val), []));\n\n    }\n\n}\n\nmodule.exports = Quadtree;"]}